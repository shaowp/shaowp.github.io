<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="Shaowp,15751110745@163.com"><title>关于单片机内部程序的一些理解 · 过往</title><meta name="description" content="最近研究键盘，基本上都是用Atmega 32U4来做的，这个MCU其实是arduino上的串口芯片，内置了一段固定程序而已，可以通过arduino板进行烧写研究键盘的时候发现这个东西是用DFU来刷程序的，但是不太理解DFU是啥，顺带着查了一些bootloader的资料，现在有了一些简单的认识。（现在"><meta name="keywords" content="stm32,Linux,arduino,raspberry,C"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="http://markdown.shaowp.cn/img/20190204/Quo64PAXWvpC.jpg?imageslim" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/water.jpg" style="width:127px;"><h3 title=""><a href="/">过往</a></h3><div class="description"><p>随风而去，留下回忆.</p></div></div></div><ul class="social-links"><li><a href="http://github.com/shaowp"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai </a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a class="fa fa-chevron-left" onclick="window.history.go(-1)"> </a></li></div><div class="avatar"><img src="/images/my_head.jpg"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>关于单片机内部程序的一些理解</a></h3></div><div class="post-content"><p>最近研究键盘，基本上都是用Atmega 32U4来做的，这个MCU其实是arduino上的串口芯片，内置了一段固定程序而已，可以通过arduino板进行烧写<br>研究键盘的时候发现这个东西是用DFU来刷程序的，但是不太理解DFU是啥，顺带着查了一些bootloader的资料，现在有了一些简单的认识。（现在凌晨三点半，困死了）<br><br><br><br>下面的内容将以stm32和arduino为例<br><strong>首先了解几个术语：ISP，IAP</strong></p>
<h4 id="ISP"><a href="#ISP" class="headerlink" title="ISP"></a>ISP</h4><p>ISP为系统在线编程的简称，在上古时代，给单片机烧写程序是用专用的烧写器来烧写的，需要把芯片拿下来插到特定的烧写器，接插的还好，焊接的就非常不方便了，于是有了系统在线编程，即不需要把芯片拿下来，只需通过几个串行总线（如：UART，IIC，SPI等）来烧写程序。<br>但是我们都知道，如果要使用这些总线，是需要经过初始化、函数编程的，即使在烧写程序的时候也不例外。于是就有了bootloader</p>
<h4 id="bootloader"><a href="#bootloader" class="headerlink" title="bootloader"></a>bootloader</h4><p>假设我们把单片机的内存想象成一个有序排列的，有地址的格子，like下面的样子，第一个地址是0x0000…，再假设，我们的单片机是从第一个格子开始执行。<br><strong>插入图片</strong><br>那一般情况下我们需要将我们的执行程序烧写到从0x00开始的。那现在的问题就是如何把用户的二进制文件下载到单片机的格子里。因此bootloader就是干这个任务的。<br>bootloader实质上是一段程序，这个程序从第一个格子开始，因此，单片机上电之后首先会执行bootloader程序。<br>在bootloader里，会初始化几个串行总线的协议（以串口为例），会初始化一些和计算机通信握手的东西，接着就是等待计算机从串口将二进制文件发送过来，最后bootloader将用户的二进制存到bootloader后面的地址。<br>这时我们再会过头来思考一下整个执行过程  </p>
<ol>
<li>系统上电复位初始化，PC指针指向0x00</li>
<li>开始执行bootloader程序，初始化协议</li>
<li>是否有电脑端发送的用户二进制程序，如果有，则将二进制文件烧写到bootloader后面的地址，如果没有则执行第四步</li>
<li>执行用户程序</li>
</ol>
<p>下面以arduino为例<br>arduino上电会先执行社区写的bootloader，此时如果和IDE的握手或者说通信协议啥的匹配，就会进入烧写模式，等待IDE将二进制文件从串口发过来，bootloader将二进制文件送到指定的内存地址。接着执行用户程序（这里的描述其实不太准确，只是为了便于理解，实际上是借助那个小的MCU来实现复位的）</p>
<h5 id="总结：bootloader可以理解为上电后刚执行的程序，如果这段程序没了，就不能从简单的串行口烧写，就需要特定的烧写器"><a href="#总结：bootloader可以理解为上电后刚执行的程序，如果这段程序没了，就不能从简单的串行口烧写，就需要特定的烧写器" class="headerlink" title="总结：bootloader可以理解为上电后刚执行的程序，如果这段程序没了，就不能从简单的串行口烧写，就需要特定的烧写器"></a>总结：bootloader可以理解为上电后刚执行的程序，如果这段程序没了，就不能从简单的串行口烧写，就需要特定的烧写器</h5><h4 id="IAP"><a href="#IAP" class="headerlink" title="IAP"></a>IAP</h4><p>IAP比ISP更加先进一点，叫做应用编程，说白了IAP就是允许用户自定义bootloader，或者说有2个bootloader，一个bootloader是芯片出厂时固化的，另一个是用户自定义的。自定义的bootloader在固化的bootloader之后启动。也许你就要问了，用户自定义的bootloader不就是用户程序吗？其实它跟普通用户程序的区别就是它不会那么容易的被擦除。。。一般是先用专用软件，调用固化的bootloader，来写入自定义的bootloader，然后自定义的bootloader利用能写flash的能力，来给芯片写入新的程序。<br>为什么需要自定义bootloader呢？默认的bootloader需要在固定引脚，通过串口，以固定的协议传送程序。如果你对这个过程的任何一点不满意，那你就要自定义bootloader喽~</p>
<h4 id="DFU"><a href="#DFU" class="headerlink" title="DFU"></a>DFU</h4><p>上述的可能有些疑问，这里需要解释一下：<br>通常意义上arduino的bootloader实际上是用户的bootloader,即用串口给arduino烧写程序的时候其实是<strong>IAP</strong>方式烧写的，但是其实在arduino芯片内还有一段厂商bootloader，允许使用ICSP接口，差不多就是SPI接口来烧写程序。因此烧写arduino的过程其实是：<br>启动厂商bootloader——-&gt;<br>启动用户bootloader——-&gt;<br>启动用户程序<br>理解了上述问题，我们就能刚好的理解<strong>DFU</strong>，DFU可以理解为用户自定义的USB协议的bootloader，实质上和arduino的用户串口bootloader是一个性质，接口不同而已。</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2019-02-21</span><i class="fa fa-tag"></i><a class="tag" href="/tags/STM32/" title="STM32">STM32 </a><a class="tag" href="/tags/Arduino/" title="Arduino">Arduino </a><a class="tag" href="/tags/嵌入式/" title="嵌入式">嵌入式 </a></div></div></div></div><div class="share"><div class="evernote"><a class="fa fa-bookmark" href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank"></a></div><div class="weibo"><a class="fa fa-weibo" href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));"></a></div><div class="twitter"><a class="fa fa-twitter" href="http://twitter.com/home?status=,http://yoursite.com/2019/02/21/关于单片机内部程序的一些理解/,过往,关于单片机内部程序的一些理解,;"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a class="btn" role="navigation" href="/2019/02/04/Git使用笔记/" title="Git使用笔记">下一篇</a></li></ul></div></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>